From fe0b3d28ce98d67c2d296819517857a23d4217d3 Mon Sep 17 00:00:00 2001
From: Zubin Mithra <zsm@google.com>
Date: Thu, 15 Jun 2023 19:48:01 +0000
Subject: [PATCH] cros-syzkaller: log canonicalizer info

---
 pkg/cover/canonicalizer.go | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/pkg/cover/canonicalizer.go b/pkg/cover/canonicalizer.go
index 48b1bb3df..7000e63c5 100644
--- a/pkg/cover/canonicalizer.go
+++ b/pkg/cover/canonicalizer.go
@@ -44,9 +44,12 @@ func NewCanonicalizer(modules []host.KernelModule, flagSignal bool) *Canonicaliz
 	if len(modules) == 0 || !flagSignal {
 		return &Canonicalizer{}
 	}
+	log.Logf(0, "DEBUG: Canonical module count: [%v]", len(modules))
+	log.Logf(0, "DEBUG: Canonical modules : [%v]", len(modules))
 	// Create a map of canonical module offsets by name.
 	canonicalModules := make(map[string]host.KernelModule)
 	for _, module := range modules {
+		log.Logf(0, "-- %v", module.Name)
 		canonicalModules[module.Name] = module
 	}
 
@@ -63,6 +66,9 @@ func (can *Canonicalizer) NewInstance(modules []host.KernelModule) *Canonicalize
 	if can.moduleKeys == nil {
 		return &CanonicalizerInstance{}
 	}
+	log.Logf(0, "DEBUG: Instance module count: [%v]\n", len(modules))
+	log.Logf(0, "DEBUG: Instance modules : [%v]", len(modules))
+
 	// Save sorted list of module offsets.
 	moduleKeys := make([]uint32, len(modules))
 	setModuleKeys(moduleKeys, modules)
@@ -71,6 +77,7 @@ func (can *Canonicalizer) NewInstance(modules []host.KernelModule) *Canonicalize
 	instToCanonicalMap := make(map[uint32]*canonicalizerModule)
 	canonicalToInstMap := make(map[uint32]*canonicalizerModule)
 	for _, module := range modules {
+		log.Logf(0, "-- %v", module.Name)
 		canonicalModule, found := can.modules[module.Name]
 		if !found || canonicalModule.Size != module.Size {
 			log.Fatalf("kernel build has changed; instance module %v differs from canonical", module.Name)
@@ -153,6 +160,13 @@ func (convert *Convert) convertPCs(cov []uint32, sign signal.Serial) {
 
 func (convert *Convert) convertPC(pc uint32) uint32 {
 	moduleIdx := findModule(pc, convert.moduleKeys)
+	if _, ok := convert.conversionHash[convert.moduleKeys[moduleIdx]]; !ok {
+		log.Logf(0, "DEBUG: convertPC: moduleIdx=[%v] convert.moduleKeys[moduleIdx]=[%v]\n", moduleIdx, convert.moduleKeys[moduleIdx])
+		log.Logf(0, "DEBUG: dumping conversionHash")
+		for key, value := range convert.conversionHash {
+			log.Logf(0, "DEBUG: address=%x offset=%x endAddr=%x", key, value.offset, value.endAddr)
+		}
+	}
 	// Check if address is above the first module offset.
 	if moduleIdx >= 0 {
 		module := convert.conversionHash[convert.moduleKeys[moduleIdx]]
-- 
2.41.0.162.gfafddb0af9-goog

